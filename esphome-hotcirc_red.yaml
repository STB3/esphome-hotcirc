esphome:
  name: esphome-hotcirc-red
  name_add_mac_suffix: false
  comment: HotCirc hot water circulation controller
  platformio_options:
    board_build.arduino.memory_type: qio_opi
  on_boot:
    then:
      - lambda: |-
          if (!id(wifi_connected)) {
            id(ap_mode_blink).execute();
          }

esp32:
  variant: esp32c6
  framework:
    type: esp-idf

external_components:
  - source:
      type: local
      path: !secret local_path
    components: [esphome_hotcirc]

logger:
  level: INFO
#  hardware_uart: UART0
#  baud_rate: 115200

api:
  reboot_timeout: 600min

ota:
  platform: esphome

web_server:
  version: 3
  port: 80
  include_internal: true     # exposes internal handlers

wifi:
# Uncomment this if you have entered your credentials in the secrets.yaml
# anyway at least the api_encryption_key: section must be present in the secrets.yaml
#  ssid: !secret wifi_ssid
#  password: !secret wifi_password
  power_save_mode: NONE
  ap:
    ssid: "ESPhome-HotCirc"
  reboot_timeout: 0s

  on_connect:
    - script.stop: ap_mode_blink
    - output.turn_on: wifi_led
    - globals.set:
        id: wifi_connected
        value: 'true'

  on_disconnect:
    - script.execute: ap_mode_blink
    - globals.set:
        id: wifi_connected
        value: 'false'

captive_portal:

globals:
  - id: wifi_connected
    type: bool
    restore_value: no
    initial_value: 'false'

# === Sensors & Temperature Probes ===
one_wire:
- platform: gpio
  id: ow_bus
  pin: GPIO21

sensor:
  - platform: dallas_temp
    one_wire_id: ow_bus
    address: 0x20000000b17e2328
    name: "Outlet Temperature"
    id: outlet_temp
    update_interval: 1s
    accuracy_decimals: 2
    filters:
      - sliding_window_moving_average:  # Smooth out sensor noise
          window_size: 3
          send_every: 1

  - platform: dallas_temp
    one_wire_id: ow_bus
    address: 0x23000000b178e328
    name: "Return Temperature"
    id: return_temp
    update_interval: 1s
    accuracy_decimals: 2
    filters:
      - sliding_window_moving_average:
          window_size: 3
          send_every: 1

  # ADC for pump internal temperature sensor
  # Purpose: Monitor pump's built-in thermistor/temperature sensor
  # Hardware: Voltage divider before ADC input: V_ADC = 0.45 * V_pump
  # Pump sensor output: 0-3.3V (full range)
  # ADC measures: 0-1.485V (after divider)
  # Goal: Correlate voltage with actual water temperature for future use
  # May eventually replace external DS18B20 outlet sensor
  - platform: adc
    pin: GPIO1
    name: "Pump Temperature ADC (Raw)"
    id: pump_temp_adc_raw
    attenuation: 0db  # 0-1.1V range, extended to ~1.5V
    samples: 10
    update_interval: 1s  # Match DS18B20 update rate for correlation
    unit_of_measurement: "V"
    accuracy_decimals: 4
    internal: true  # Hide raw ADC value

  # Calculate actual pump sensor voltage (before divider)
  - platform: template
    name: "Pump Sensor Voltage"
    id: pump_sensor_voltage
    update_interval: 1s
    lambda: |-
      float v_adc = id(pump_temp_adc_raw).state;
      if (isnan(v_adc)) return NAN;

      // V_pump = V_ADC / 0.45
      float v_pump = v_adc / 0.45;

      return v_pump;
    unit_of_measurement: "V"
    accuracy_decimals: 3
    device_class: voltage
    internal: true  # Hidden - not used in any algorithm, only for logging

  # Template sensor to log both values together for correlation analysis
  - platform: template
    name: "Outlet vs Pump Voltage"
    id: correlation_log
    update_interval: 10s
    lambda: |-
      if (!isnan(id(outlet_temp).state) && !isnan(id(pump_sensor_voltage).state)) {
        // Calculate return temperature from NTC thermistor using accurate formula
        float adc_raw = id(pump_temp_adc_raw).state;
        float return_measured = id(return_temp).state;
        bool pump_running = id(hotwater).pump_running_;
        float Vntc = id(pump_sensor_voltage).state;  // Pump_V voltage

        // NTC thermistor temperature calculation
        // Input: Vntc = Pump_V voltage in volts
        float r   = Vntc / (3.3f - Vntc);
        float lnr = logf(r);
        float invT = 0.00275456f
                   - 0.00136672f * lnr
                   + 0.00117880f * lnr * lnr * lnr;
        float calc_return_temp = 1.0f / invT - 273.15f;

        if (pump_running && !isnan(adc_raw)) {
          // Log both measured and calculated return temperatures during pump operation
          if (!isnan(return_measured)) {
            ESP_LOGI("correlation", "Outlet=%.2f°C, Pump_V=%.3fV (ADC_raw=%.4fV), Return(DS18B20)=%.2f°C, Return(NTC)=%.1f°C",
                     id(outlet_temp).state,
                     id(pump_sensor_voltage).state,
                     adc_raw,
                     return_measured,
                     calc_return_temp);
          } else {
            ESP_LOGI("correlation", "Outlet=%.2f°C, Pump_V=%.3fV (ADC_raw=%.4fV), Return(NTC)=%.1f°C",
                     id(outlet_temp).state,
                     id(pump_sensor_voltage).state,
                     adc_raw,
                     calc_return_temp);
          }
        } else {
          // When pump is off, just show basic info with DS18B20 return temp if available
          if (!isnan(return_measured)) {
            ESP_LOGI("correlation", "Outlet=%.2f°C, Pump_V=%.3fV (ADC_raw=%.4fV), Return(DS18B20)=%.2f°C",
                     id(outlet_temp).state,
                     id(pump_sensor_voltage).state,
                     adc_raw,
                     return_measured);
          } else {
            ESP_LOGI("correlation", "Outlet=%.2f°C, Pump_V=%.3fV (ADC_raw=%.4fV)",
                     id(outlet_temp).state,
                     id(pump_sensor_voltage).state,
                     adc_raw);
          }
        }
        return id(outlet_temp).state;  // Return outlet temp as sensor value
      }
      return NAN;
    unit_of_measurement: "°C"
    accuracy_decimals: 2
    internal: true  # Don't expose to HA, just for logging

  - platform: wifi_signal
    name: "HotCirc WiFi Signal"
    id: wifi_signal_sensor
    update_interval: 60s

  # NTC Thermistor Temperature (from pump internal sensor)
  - platform: template
    name: "Pump NTC Temperature"
    id: pump_ntc_temp
    update_interval: 1s
    lambda: |-
      float Vntc = id(pump_sensor_voltage).state;
      if (isnan(Vntc)) return NAN;

      // NTC thermistor temperature calculation
      // Input: Vntc = Pump_V voltage in volts
      float r   = Vntc / (3.3f - Vntc);
      float lnr = logf(r);
      float invT = 0.00275456f
                 - 0.00136672f * lnr
                 + 0.00117880f * lnr * lnr * lnr;
      float T_C = 1.0f / invT - 273.15f;

      return T_C;
    unit_of_measurement: "°C"
    accuracy_decimals: 1
    device_class: temperature
    state_class: measurement
    icon: "mdi:thermometer"
    internal: true  # Hidden - not used in any algorithm, only for correlation logging

  # Last pump cycle energy consumption
  - platform: template
    name: "Last Cycle Energy"
    id: last_cycle_energy
    update_interval: 5s
    lambda: |-
      return id(hotwater).get_last_cycle_energy();
    unit_of_measurement: "kWh"
    accuracy_decimals: 4
    device_class: energy
    state_class: total_increasing
    icon: "mdi:lightning-bolt"

  # Last pump cycle duration
  - platform: template
    name: "Last Cycle Duration"
    id: last_cycle_duration
    update_interval: 5s
    lambda: |-
      return id(hotwater).get_last_cycle_duration();
    unit_of_measurement: "s"
    accuracy_decimals: 0
    icon: "mdi:timer-outline"


text_sensor:
  - platform: template
    name: "Pump Status"
    id: pump_status
    icon: "mdi:information-outline"
    update_interval: 1s
    lambda: |-
      if (id(hotwater).pump_running_) {
        // Get trigger reason
        auto trigger = id(hotwater).get_pump_trigger();
        std::string trigger_str;

        switch(trigger) {
          case esphome::esphome_hotcirc::HotWaterController::PumpTrigger::MANUAL_BUTTON:
            trigger_str = "Manual Button";
            break;
          case esphome::esphome_hotcirc::HotWaterController::PumpTrigger::MANUAL_WEBUI:
            trigger_str = "Web UI";
            break;
          case esphome::esphome_hotcirc::HotWaterController::PumpTrigger::WATER_DRAW:
            trigger_str = "Water Draw";
            break;
          case esphome::esphome_hotcirc::HotWaterController::PumpTrigger::SCHEDULED:
            trigger_str = "Scheduled";
            break;
          case esphome::esphome_hotcirc::HotWaterController::PumpTrigger::DISINFECTION:
            trigger_str = "Disinfection";
            break;
          case esphome::esphome_hotcirc::HotWaterController::PumpTrigger::ANTI_STAGNATION:
            trigger_str = "Anti-Stagnation";
            break;
          default:
            trigger_str = "Unknown";
        }

        return std::string("Running: ") + trigger_str;
      } else if (!id(hotwater).pump_enabled_) {
        return std::string("Disabled");
      } else {
        return std::string("Standby");
      }

  - platform: template
    name: "System Mode"
    id: system_mode
    icon: "mdi:home-automation"
    update_interval: 10s
    lambda: |-
      if (id(hotwater).is_vacation_mode()) {
        return {"Vacation Mode"};
      } else {
        return {"Normal"};
      }

  - platform: template
    name: "Learning Matrix JSON"
    id: learning_matrix_json
    update_interval: 300s  # Update every 5 minutes for learning changes
                           # Also updates immediately when ECO level changes (see ECO Level number component)
    internal: false  # Make it accessible via web/API
    lambda: |-
      // Build JSON string from learning matrix including ECO level
      std::string json = "{\"eco_level\":";
      json += std::to_string((int)id(hotwater).SCHEDULE_THRESHOLD);
      json += ",\"days\":[";

      const char* dayNames[] = {"Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"};

      for (int day = 0; day < 7; day++) {
        if (day > 0) json += ",";
        json += "{\"name\":\"" + std::string(dayNames[day]) + "\",\"values\":[";

        for (int slot = 0; slot < 48; slot++) {
          if (slot > 0) json += ",";
          // Use std::to_string for proper conversion
          json += std::to_string((int)id(hotwater).learn_[day][slot]);
        }

        json += "]}";
      }

      json += "]}";

      return json;

switch:
  - platform: gpio
    id: pump_relay
    pin: GPIO14
    restore_mode: ALWAYS_OFF  # Safety: ensure pump is off on boot
    internal: true  # Hide from UI - controlled internally

  # Master enable/disable switch for pump operation
  - platform: template
    name: "Circulation Pump Enable"
    id: pump_enable_switch
    icon: "mdi:pump"
    restore_mode: RESTORE_DEFAULT_ON  # Default to enabled on boot
    optimistic: true
    lambda: |-
      return id(hotwater).pump_enabled_;
    turn_on_action:
      - lambda: |-
          ESP_LOGI("pump_switch", "Pump ENABLED via Web UI");
          id(hotwater).enable_pump();
    turn_off_action:
      - lambda: |-
          ESP_LOGI("pump_switch", "Pump DISABLED via Web UI");
          id(hotwater).disable_pump();

button:
  - platform: template
    name: "Run Circulation Pump"
    icon: "mdi:pump"
    on_press:
      - lambda: |-
          ESP_LOGI("pump_button", "Web UI: Pump run requested");
          id(hotwater).run_pump();

  - platform: template
    name: "Save Learning Matrix"
    icon: "mdi:content-save"
    on_press:
      - lambda: |-
          ESP_LOGI("save_button", "Web UI: Save learning matrix requested");
          id(hotwater).save_learning_matrix();

number:
  - platform: template
    name: "Outlet Rise Threshold"
    id: outlet_rise_config
    icon: "mdi:thermometer-chevron-up"
    min_value: 0.5
    max_value: 3.0
    step: 0.1
    initial_value: 1.0
    optimistic: true
    unit_of_measurement: "°C"
    mode: slider
    on_value:
      - lambda: |-
          id(hotwater).temp_rise_threshold_ = x;
          ESP_LOGI("config", "Outlet rise threshold changed to %.1f°C", x);

  - platform: template
    name: "Return Rise Target"
    id: return_rise_config
    icon: "mdi:thermometer-alert"
    min_value: 3.0
    max_value: 15.0
    step: 0.5
    initial_value: 5.0
    optimistic: true
    unit_of_measurement: "°C"
    mode: slider
    on_value:
      - lambda: |-
          id(hotwater).return_rise_threshold_ = x;
          ESP_LOGI("config", "Return rise target changed to %.1f°C", x);

  - platform: template
    name: "Min Return Temperature"
    id: min_return_temp_config
    icon: "mdi:thermometer-low"
    min_value: 25.0
    max_value: 40.0
    step: 1.0
    initial_value: 30.0
    optimistic: true
    unit_of_measurement: "°C"
    mode: slider
    on_value:
      - lambda: |-
          id(hotwater).min_return_temp_ = x;
          ESP_LOGI("config", "Min return temperature changed to %.1f°C", x);

  - platform: template
    name: "Disinfection Temp Rise"
    id: disinfection_temp_rise_config
    icon: "mdi:biohazard"
    min_value: 5.0
    max_value: 20.0
    step: 1.0
    initial_value: 10.0
    optimistic: true
    unit_of_measurement: "°C"
    mode: slider
    on_value:
      - lambda: |-
          id(hotwater).disinfection_temp_threshold_ = x;
          ESP_LOGI("config", "Disinfection temp rise changed to %.1f°C", x);

  - platform: template
    name: "Pump Flow Rate"
    id: pump_flow_rate_config
    icon: "mdi:waves-arrow-right"
    min_value: 5.0
    max_value: 40.0
    step: 1.0
    initial_value: 20.0
    optimistic: true
    unit_of_measurement: "L/min"
    mode: box
    on_value:
      - lambda: |-
          id(hotwater).pump_flow_rate_ = x;
          ESP_LOGI("config", "Pump flow rate changed to %.1f L/min", x);

  - platform: template
    name: "ECO Level"
    id: eco_level_config
    icon: "mdi:leaf"
    min_value: 0
    max_value: 255
    step: 5
    initial_value: 120
    optimistic: true
    mode: slider
    on_value:
      - lambda: |-
          // ECO level: higher value = more eco-friendly = pump runs less often
          // Value directly matches learning matrix values shown in heatmap
          // Range 0-255: 0 = always run, 255 = only run when absolutely certain
          id(hotwater).SCHEDULE_THRESHOLD = (uint8_t)x;
          ESP_LOGI("config", "ECO level changed to %.0f (threshold = %d)", x, (uint8_t)x);
          // Immediately update the JSON sensor so heatmap shows new trigger thresholds
          id(learning_matrix_json).update();

output:
  - platform: gpio
    id: led_green
    pin: GPIO2
  - platform: gpio
    id: led_yellow
    pin: GPIO3
  - platform: gpio
    id: wifi_led
    pin: GPIO22

binary_sensor:
  - platform: gpio
    pin:
      number: GPIO23
      mode: INPUT_PULLUP
      inverted: true
    id: hw_button
    name: "Manual Pump Button"
    filters:
      - delayed_on: 50ms  # Debounce
    internal: true  # Hidden - LED provides sufficient feedback

time:
  - platform: sntp
    id: sntp_time
    timezone: Europe/Amsterdam
    servers: ["0.nl.pool.ntp.org", "1.nl.pool.ntp.org", "2.nl.pool.ntp.org"]
    on_time_sync:
      - logger.log: "Time synchronized"

script:
  - id: ap_mode_blink
    mode: restart
    then:
#      - logger.log: "AP mode blinking started"
      - while:
          condition:
            lambda: 'return !id(wifi_connected);'
          then:
            - output.turn_on: wifi_led
            - delay: 200ms
            - output.turn_off: wifi_led
            - delay: 1000ms

# === Instantiate component ===
esphome_hotcirc:
  id: hotwater
  outlet_sensor: outlet_temp
  return_sensor: return_temp
  pump_switch: pump_relay
  time_source: sntp_time
  button: hw_button
  led_green: led_green        # Reference to output, not light
  led_yellow: led_yellow      # Reference to output, not light
  outlet_rise: 1.0      # Minimum temperature RISE to detect water draw (°C)
                        # Reduced from 1.5 to match slower temperature response in 40cm pipe
  return_rise: 5.0      # Target return temperature rise for normal operation (°C)
  disinfection_temp_rise: 10.0  # Temperature rise above baseline indicating disinfection cycle (°C)
                                # When detected, pump runs maximum time to disinfect entire system
  min_return_temp: 30.0  # Minimum return temperature to start pump (°C)
                         # If return temp is above this, water at taps is already hot enough
                         # Prevents unnecessary pump runs, saves energy
  pump_flow_rate: 20.0   # Pump flow rate in liters per minute (L/min)
                         # Measured value: 20 L/min
                         # Used for energy consumption calculation
  anti_stagnation_interval: 172800  # Anti-stagnation interval in seconds (default: 48 hours)
                                    # Pump runs for short duration when disabled or in vacation mode
                                    # to prevent impeller seizure
  anti_stagnation_runtime: 15       # Anti-stagnation run time in seconds (default: 15 seconds)
                                    # Short run is enough to move impeller and prevent seizure
